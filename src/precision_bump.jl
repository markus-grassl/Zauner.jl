export re_im_proj, precision_bump, precision_bump!, pow_to_elem_sym_poly


@doc raw"""
    re_im_proj(ψ::Vector{Complex{BigFloat}})
    re_im_proj(z::Vector{BigFloat})

\\
Stack the real and imaginary parts of the vector `ψ` and normalize so that 
the first coordinate, assumed nonzero, is normalized to 1 and then dropped. 

\\
If called with type `Vector{BigFloat}` then it does the inverse transformation, taking an even-length real vector to a complex one with unit first coordinate. 

# Examples
First compute a ghost fiducial at 128-bit precision.
```jldoctest
julia> ψ = ghost(AdmissibleTuple(4))
4-element Vector{Complex{BigFloat}}:
                                           1.0 + 0.0im
    -1.450040917064870363492276300052115018856 + 1.086494885600835303229997681861825010053im
 3.461386835844328224330659532976818956393e-33 - 2.414213562373095048801688724209694245958im
    -0.964172645308224685309412424157583553268 - 0.08649488560083530322999768186182690796257im
julia> z = re_im_proj(ψ)
6-element Vector{BigFloat}:
 -1.450040917064870363492276300052115018856
  3.461386835844328224330659532976818956393e-33
 -0.964172645308224685309412424157583553268
  1.086494885600835303229997681861825010053
 -2.414213562373095048801688724209694245958
 -0.08649488560083530322999768186182690796257
```
"""
re_im_proj(ψ::Vector{Complex{BigFloat}}) = [real.(ψ./ψ[1])[2:end]; imag.(ψ./ψ[1])[2:end]]

function re_im_proj(z::Vector{BigFloat})
    @assert length(z) % 2 == 0    
    [1; z[1:end÷2]] .+ im * [0; z[(1+end÷2):end]]
end



# Take the real and imaginary parts with projective normalization and 
# return the overlap function for a ghost fiducial.
# NOTE: This function has an eight-fold symmetry as a function of (p,q)
# generated by the transformations:
#    (p,q) → (-p,-q)
#    (p,q) → ( q, p)
#    (p,q) → ( p,-q)*
# where the last one means apply the symmetry then complex conjugate the result.

function _ghost_olp_func(z,r,p,q)
    T = eltype(z)
    d  = 1+length(z)÷2
    x0 = [  one(T); z[1:d-1] ] # real part of ψ
    y0 = [ zero(T); z[d:end]]  # imag part of ψ
    xi = circshift(reverse(x0),1)
    yi = circshift(reverse(y0),1)
    xp = circshift(xi,-p)
    yp = circshift(yi,-p)
    xq = circshift(xi,-q)
    yq = circshift(yi,-q)
    xr = circshift(x0,-p-q)
    yr = circshift(y0,-p-q)
    
    # real and imaginary parts.
    if r == 0
        # real part
        sum((xq .* xr + yq .* yr) .* (x0 .* xp + y0 .* yp) + 
            (xr .* yq - xq .* yr) .* (xp .* y0 - x0 .* yp) ) - 
        ((p==0) + (q==0))/(d+one(T)) * sum(xi.*x0 + yi.*y0)^2
    elseif r==1
        # imaginary part
        if ( p==0 || q == 0 || 2p == d || 2q == d )
            zero(T) # these values are manifestly real and don't contribute.
        else
            sum((xq .* yr - yq .* xr) .* (x0 .* xp + y0 .* yp) + 
                (yr .* yq + xq .* xr) .* (xp .* y0 - x0 .* yp) )
        end
    end
end


# both real and imaginary parts on a combined index
_ghost_olp_func(z,n::Integer) = _ghost_olp_func(z, radix(n, [2,1+(length(z)÷2),1+(length(z)÷2)])... )

# list over a vector
_ghost_olp_func(z,v::AbstractVector) = [ _ghost_olp_func(z,n) for n in v ]


function _ghost_olp_func(z)
    d = 1+length(z)÷2
    #=
        *Empirically*, the following list is sufficient to get a 
        square and full-rank Jacobian. There is room to optimize this.
        *No check* is done to ensure that the Jacobian is full rank, 
        nor is any effort spent on optimizing the condition number through
        a judicious choice of rows. However, after taking the symmetries of 
        the function into account, and dropping the (p,q) == (0,0) equation,
        these are the lexigraphically first independent terms in the real 
        and imaginary parts. It is thus plausible that they should give a 
        full-rank Jacobian, at least for generic perturbations. 
    =#
    v = [ [            q for q=1:d÷2];        # real part, first row
          [        d + q for q=1:d÷2];        # real part, second row
          [       2d + q for q=2:d÷2];        # real part, third row
          [ d^2 +  d + q for q=1:(d-1)÷2];    # imag part, second row
          [ d^2 + 2d + q for q=2:(1-(-1)^d)]  # imag part, one element in the third row for odd d
        ]
    _ghost_olp_func(z,v)
end


@doc raw"""
    precision_bump(ψ::Vector{Complex{BigFloat}}, prec::Integer [; base::Integer = 10, verbose::Bool = true])

Attempt to use Newton's method to improve the precision of `ψ` to at least `prec` digits in base `base`. 
"""
function precision_bump(ψ::Vector{Complex{BigFloat}}, prec::Integer; base::Integer = 10, verbose::Bool = true)
    z = re_im_proj(ψ)
    precision_bump!(z, prec; base, verbose)
    re_im_proj(z)
end

@doc raw"""
    precision_bump!(z::Vector{BigFloat}, prec::Integer [; base::Integer = 10, verbose::Bool = true])

Attempt to use Newton's method to improve the precision of `z` to at least `prec` digits in base `base`, 
where `z` is the real projective representation of `ψ`. 
"""
function precision_bump!(z::Vector{BigFloat}, prec::Integer; base::Integer = 10, verbose::Bool = true)
    @assert base > 1 "base must be an integer ≥ 2"
    if base == 2
        basename = "bits"
    elseif base == 10
        basename = "digits"
    else
        basename = "digits base $base"
    end
    verbose && println("Increase ghost precision...")
    digits = floor( Int, -log( base, maximum(abs.(_ghost_olp_func(z)))) )
    while digits < prec
        setprecision( BigFloat, 2*digits; base = base)
        verbose && println("Current ghost precision is $digits $basename.")
        # Run an iteration of Newton's method
        if verbose
            @time z .-= jacobian(_ghost_olp_func, z)\_ghost_olp_func(z)
        else
            z .-= jacobian(_ghost_olp_func, z)\_ghost_olp_func(z)
        end
        digits = floor( Int, -log( base, maximum(abs.(_ghost_olp_func(z)))) )
    end
    verbose && println("Precision of BigFloat is now ", precision(BigFloat; base = base), " $basename.")
    verbose && println("Final ghost precision is $digits $basename.")
    return z
end



@doc raw"""
    pow_to_elem_sym_poly( p::Vector{<:AbstractFloat}) 

\\
Take an abstract vector `p` and apply the recursion relation for 
converting power sums to elementary symmetric polynomials assuming 
that `p[1]` is the first power sum. 
Output `e` is indexed so that `e[1] == 1` is the zeroth elementary 
symmetric polynomial and `length(e) == length(p)+1`. 
"""
function pow_to_elem_sym_poly(p::Vector{<:AbstractFloat})
    L = length(p)
    esp = copy(p)
    pushfirst!( esp, one(eltype(p))) # e0 = 1
    for k=1:L
        esp[k + 1] = sum( [ (-1)^(j-1)*esp[k-j+1]*p[j]/k for j=1:k] )
    end
    esp
end



@doc raw"""
    to_quadratic( x::BigFloat) 

\\
Find quadratic integer relations for real numbers. 

If only one argument is specified, then the output is a purported integer relation `y` of type `Vector{BigInt}`, meaning `v` is such that `v' * [1; x; x^2]` is approximately zero to within the precision with which `x` is specified. 
That is, `v` are the purported coefficients of a quadratic polynomial for which `x` is a numerical (real) root. 

----

    to_quadratic( x::BigFloat, y::Integer)
    to_quadratic( x::BigFloat, y::ZZRingElem)

\\
If a positive integer `y` is specified, then it looks for integer relations `v` which approximately nullify `[x; 1; sqrt(y)]`. 

----

    to_quadratic( x::BigFloat, K::AnticNumberField)

\\
If a number field `K` is specified, then it looks for integer relations `v` which approximately nullify `[x; 1; y]` where `y = K[1]` is the generator of `K`. 
In this case however, the result is returned as type `nf_elem` in the number field `K`. 
No test is done to check if `K` is a real quadratic field, so the results will be unpredictable garbage if a general field is used here.

----

    to_quadratic( x::BigFloat, y::nf_elem)

\\
If `K = y.parent` is the parent number field of `y`, this is equivalent to `to_quadratic( x,  K)`. 

# Examples

TBD...

"""
function to_quadratic( x::BigFloat)
    prec = precision( x; base = 10)-10
    n = ZZ(10)^prec
    nx = ZZ(round(n*x))
    nx2 = ZZ(round(n*x^2))
    L = matrix_space(ZZ,3,4)
    T = L([1 0 0 n; 0 1 0 nx; 0 0 1 nx2])
    B = dropdims(BigInt.(lll(T)[1,:]),dims=1)[1:3]
    B #, floor(Int,-log10(abs([1; x; x^2]'*B)))
end

function to_quadratic( x::BigFloat, y::Union{Integer,ZZRingElem})
    @assert y > 0
    prec = precision( x; base = 10)-10
    n = ZZ(10)^prec
    nx = ZZ(round(n*x))
    ny = ZZ(round(n*sqrt(BigFloat(y))))
    L = matrix_space(ZZ,3,4)
    T = L([1 0 0 nx; 0 1 0 n; 0 0 1 ny])
    B = dropdims(BigInt.(lll(T)[1,:]),dims=1)[1:3]
    B #, floor(Int,-log10(abs([x; 1; sqrt(BigFloat(y))]'*B)))
end

function to_quadratic( x::BigFloat, K::AnticNumberField)
    v = to_quadratic( x, ZZ(K[1]^2))
    (v[2] + v[3]*K[1])/(-v[1])
end

to_quadratic( x::BigFloat, y::nf_elem) = to_quadratic( x, y.parent)



@doc raw"""
    guess_algebraic( x::BigFloat, n::Integer [; warn::Bool=false]) 

\\
Attempt to find an integer relation between `x^k` for `k = 0:n`. 
If `x` is a degree-`d` algebraic number with `d ≤ n`, then given sufficient precision this algorithm should find the minimal polynomial for `x`. 
If `p = [ x^(j-1) for j=1:n+1 ]` is the vector of the first `n+1` powers of `x`, then the output `v` is of type `Vector{BigInt}` and, if successful, is such that the dot product `p'*v` is approximately zero to within close to the input precision of `x`. 
No guarantees are provided for the suggested relation. 

If the optional keyword `warn` is set to `true`, then we throw a warning when `p'*v` does not vanish to at least `precision(x) - 2*n` bits of precision.

# Examples
The number `x` is a root of the minimal polynomial `-12 - 9x + x^3`. 
```jldoctest
julia> x = BigFloat(3)^(1/BigFloat(3))+BigFloat(3)^(2/BigFloat(3));

julia> guess_algebraic( x, 3)
4-element Vector{BigInt}:
 -12
  -9
   0
   1
```
However, there is no guarantee that the "correct" integer relation is found. 
The following degree-6 relation is correct, but is not minimal.
```jldoctest
julia> guess_algebraic( x, 6)
7-element Vector{BigInt}:
 -12
 -21
  15
   7
  -8
  -2
   1
```
Starting with degree 2 gives nonsensically large integers without warning. 
```
julia> guess_algebraic( x, 2)
3-element Vector{BigInt}:
 -589849553474396944841650177372651089432036255660583
  174719368381549603416539665878016040927750384288501
   -2060986329311871092129641387934536051174286616312
```
"""
function guess_algebraic( x::BigFloat, n::Integer; warn::Bool = false)
    prec = precision(x)
    t = ZZ(2)^prec
    v = [ ZZ(round(t*x^k)) for k=0:n ]
    L = matrix_space(ZZ,n+1,n+2)
    T = L([ ZZ(j==k) + (k==n+1)*v[j+1] for j=0:n, k=0:n+1])
    B = dropdims(BigInt.(lll_with_removal(T,t)[2][1,:]),dims=1)[1:n+1]
    
    if warn && -log2( abs([ x^(j-1) for j=1:n+1 ]'*B) ) - prec + 2n < 0
        @warn "Precision of dot product is low; integer relation may be spurious."
    end
    
    return B
end


# algebraic of degree n over a quadratic base field with known discriminant √D
function guess_algebraic_over_quadratic( x::BigFloat, n::Integer, D::Integer; warn::Bool = false)
    prec = precision(x)
    t = ZZ(2)^prec
    s = sqrt(BigFloat(D))
    v = [ ZZ(round(t*s^j*x^k)) for k=0:n, j=0:1][1:end-1]
    L = matrix_space(ZZ,2n+1,2n+2)
    T = L([ ZZ(j==k) + (k==2n+1)*v[j+1] for j=0:2n, k=0:2n+1])
    B = dropdims(BigInt.(lll_with_removal(T,t)[2][1,:]),dims=1)[1:2n+1]
    
    if warn && -log2( abs([ x^(j-1) for j=1:n+1 ]'*B) ) - prec + 2n < 0
        @warn "Precision of dot product is low; integer relation may be spurious."
    end
    
    return B
end



# find an integer relation between the elements of x
function guess_int_null_vec( x::Vector{BigFloat}; warn::Bool = false)
    prec = precision(x[1])
    t = ZZ(2)^prec
    n = length(x)
    v = ZZ.(round.(t .* x))
    L = matrix_space(ZZ,n,n+1)
    T = L([ ZZ(j==k) + (k==n+1)*v[j] for j=1:n, k=1:n+1])
    B = dropdims(BigInt.(lll_with_removal(T,t)[2][1,:]),dims=1)[1:n]
    
    if warn && -log2( abs([ x^(j-1) for j=1:n ]'*B) ) - prec + 2n < 0
        @warn "Precision of dot product is low; integer relation may be spurious."
    end
    
    return B
end



# Round into the class field H and then Galois conjugate
function round_conj( F::AdmissibleTuple, V::Vector{BigFloat})
    hb = lll(maximal_order(F.H)).basis_nf # find a good basis
    eH = real_embeddings(F.H)[1] # need to pick a real embedding
    prec = precision(V[1])
    fH = x -> BigFloat.(real.(evaluation_function( eH, prec).(x)))
    primalbasis = fH.(hb)
    dualbasis = fH.(F.g.(hb))
    W = copy(V)

    k = 1
    for v in V
        t = Zauner.guess_int_null_vec( [ primalbasis; v] )
        x = -t[1:end-1]/t[end]
        W[k] = dot( dualbasis, x )
        k += 1
    end
    W
end